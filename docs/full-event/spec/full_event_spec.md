# Full-Event Communication Layer Specification

## Overview
This document outlines the design and structure of a full-event communication layer, 
building on earlier versions that used hybrid (event and threaded) and message-based 
(threaded) approaches. This version leverages an event-driven architecture to efficiently 
handle communication between tasks, inspired by Java NIO concepts.


## Design Goals
1. Implement an event-driven approach where message 
   transmission and reception are triggered by events rather than direct function calls, 
   increasing flexibility and scalability.
2. Support a larger number of tasks through event handling, ensuring 
   efficient communication management across tasks.
3. Develop a modular communication layer, where each 
   component, such as brokers and queues, can be scaled and managed independently.
4. Implement non-blocking input/output similar to Java NIO, allowing tasks to focus on processing rather than waiting for data transmission.

## Advantages of a Full-Event Communication Layer
The full-event communication layer offers several benefits over traditional message-driven systems:

1.  Components do not need to know about each other's identities or 
   locations, making the system easier to maintain and scale.
2.  Event-driven architecture allows components to operate
    independently, enabling greater scalability. Components can be scaled horizontally without
     affecting the rest of the system.
3.  Events provide a natural mechanism for retry and 
   error handling. If a component fails to process an event, it can retry later without 
   blocking other parts of the system.
4. Tasks interact asynchronously, meaning no component 
   waits for another to finish processing, reducing bottlenecks and improving throughput.
5.  Events are processed as they occur, enabling the system to
    handle real-time scenarios effectively. Therefore, components can react to events as they happen.
## Component Specifications

### 1. Task
A **Task** is the basic unit of processing in the communication layer. Each task represents
an independent operation that can send and receive messages. Tasks interact with other 
tasks via brokers and message queues. A task can function as either a producer or a 
consumer, depending on the event type and its role in the system.

### 2. Broker
The **Broker** acts as the message distribution agent, providing a way for tasks to 
communicate without directly referencing each other. The broker is responsible for managing 
message queues and routing messages to their intended destinations based on established rules.

Key responsibilities of the broker include:
- Registering tasks and maintaining a registry of active tasks.
- Ensuring reliable message delivery between producer and consumer tasks.
- Managing message storage via the **Message Queue**.

### 3. Message Queue
The **Message Queue** stores messages generated by tasks and intended for other tasks. 
Message queues ensure that messages are delivered in the correct order and are processed 
only once.

Message queues are implemented to support non-blocking
 reads and writes. Each message queue operates independently, allowing multiple producers 
 and consumers to interact with minimal contention.

### 4. QueueBroker
The **QueueBroker** is an advanced version of the broker, designed to manage multiple 
message queues and coordinate exchanges between different brokers. The QueueBroker ensures
 that messages from different queues are routed appropriately and can manage complex 
 task-to-task communication scenarios.

Responsibilities include:
- Maintaining references to multiple message queues.
- Coordinating message routing across multiple brokers and tasks.
- Handling event-based message triggers.

### 5. Channel
A **Channel** represents a logical link between tasks and acts as a conduit for 
message exchange. The **Channel** in this communication 
layer is non-blocking, allowing multiple tasks to share the same channel without requiring
 blocking operations.

Channels are responsible for:
- Handling byte-level data transfer between tasks via circular buffers.
- Registering events that determine when data can be read from or written to the channel.
- Maintaining references to **Message Queue** instances to handle incoming and outgoing messages.


### 6. EventPump
The **EventPump** is responsible for managing and dispatching events throughout the system.
 It acts as the central event handler that listens for different types of events and directs
them to the appropriate handlers, such as AcceptListener, ConnectListener, and MessageListener.

### 7. AcceptListener
The **AcceptListener** listens for incoming connection requests from clients or other 
components. When a new connection request is received, it triggers an event to handle and 
establish the new connection, ensuring that the system is ready to interact with the new 
component.

### 8. ConnectListener
The **ConnectListener** is responsible for listening for successful connection attempts.
 When a connection is established between two components, the ConnectListener triggers 
 events to handle any initialization or setup tasks required for the connection.

### 9. MessageListener
The **MessageListener** listens for messages on specific channels. When a message is 
received, the MessageListener triggers the appropriate handler to process the message,
 ensuring that the message is delivered to the intended recipient and processed correctly.

## Message-Driven vs. Event-Driven Architectures
### Message-Driven Architecture

In a message-driven system, each component has a unique address where other components 
send messages. A message is data sent to a specific address, and each recipient component 
waits for incoming messages and processes them. Messages are used for targeted, 
point-to-point communication, ensuring that a specific component receives the message and 
processes it accordingly.  

In threaded programming models, Component A invoking a method in Component B was 
coupled in time. If Component B was busy or if it was slow when handling the method 
invocation, then Component A had to wait.

In Message Driven systems, Component A produces a message indicating it must be delivered 
to the address of Component B. Component A then sends the message and gets control back 
immediately instead of waiting for Component B to complete the handling of the message. 
Components on a message driven system often have a queue where incoming messages can be 
stored in case of a load spike. Message passing is a building block for space decoupling 
new tab.

In Event Driven systems, components announce a location where they expose their events. 
So a Component A emitting events will use a well-known location to publish them but not 
know which components are consuming the events. This well-known location is implemented 
using an ordered queue, here the EventQueue. Sometimes the queue is indexable so consumers can keep track of 
the events already consumed and the events pending.

### Event-Driven Architecture
In an event-driven system, components emit events without specifying who will consume 
them. Events are published to a well-known location (such as a broker), and any interested
 component can subscribe to these events. This allows for greater flexibility since the 
 emitting component does not need to know the details of the consuming components.

Using the example of three clients (A, B, C) and a server, in an event-driven system,
the clients emit events when they have data or actions that need processing. These events 
are published to a broker. The server, which subscribes to these types of events, consumes
them as they arrive. Unlike the message-driven system, the server is not directly 
addressed by the clients; instead, it reacts to events published by any client. 
This approach allows for multiple consumers to subscribe to the same event, making it
easier to scale and adapt to changing requirements.

## Event-Driven Mechanism
The full-event communication layer relies on an event-driven mechanism for sending and 
receiving messages. Events are emitted whenever a message is produced or consumed, 
triggering corresponding broker actions.

- **Message Production**: When a task produces a message, an event is generated. 
  The broker listens to this event, retrieves the message from the task, and places it in
 the appropriate **Message Queue**.
- **Message Consumption**: A consumer task registers its interest with the broker. 
    When the broker has messages available, it generates an event that triggers the 
    consumer to read from the queue.
- **Non-Blocking Channels**: Tasks interact with channels in a non-blocking manner, 
  allowing them to continue processing while waiting for messages. The event-based 
  mechanism notifies tasks when messages are available, eliminating idle wait time.
